# This is the PJS code generator.

import
  ast, strutils, trees, magicsys, options,
  nversion, msgs, idents, types, tables,
  ropes, math, passes, ccgutils, wordrecg, renderer,
  intsets, cgmeth, lowerings, sighashes, modulegraphs, lineinfos, rodutils,
  transf, injectdestructors


from modulegraphs import ModuleGraph, PPassContext

type
  TTypeSeq = seq[PType]
  TypeCache = Table[SigHash, Rope]
  BModule = ref TPjsGen
  TPjsGen = object of PPassContext
    module: PSym
    graph: ModuleGraph
    g: PGlobals
    config: ConfigRef
    s: TCFileSections
    typeCache: TypeCache # cache for generated types
    forwTypeCache: TypeCache # cache for getTypeForward()
    typeStack: TTypeSeq
  BProc = ref TProc
  TProc = object
    m: BModule
    prc: PSym # The Nim proc that this proc belongs to, can be NIL for module!
    blocks: seq[TBlock]
  PGlobals = ref object of RootObj
    typeInfo: Rope
    constants: Rope
    code: Rope
  TResKind = enum
    resNone # not set
    resExpr # is some complex expression
    resVal # is a temporary / value / l-value
  TPjsTypeKind = enum
    etyVoid # void
    etyBool # bool
    etyInt8 # i8
    etyInt16 # i16
    etyInt32 # i32
    etyFloat32 # f32
    etyFloat64 # f64
    etyUint8 # u8
    etyUint16 # u16
    etyUint32 # u32
    etyArray # array[N, T]
    etyRef # ref[T]
    etyStruct # struct Foo {...}
    etyProc # fn (...)
    etyString # string
    etyNimSeq # some struct that will be generated by pjsgen
    etyNimStr # some struct that will be generated by pjsgen
  TCompRes = object
    kind: TResKind
    typ: TPjsTypeKind
    res: Rope # result part
  TBlock = object
    sections: TCProcSections
  TCFileSection = enum
    jfsForwardTypes # section for forward typedefs
    jfsTypes # section for typedefs
    jfsSeqTypes # section for sequence types only. This is needed for strange type generation reasons.
    jfsProcHeaders # section for proc prototypes
    jfsVars # section for variable declarations
    jfsData
    jfsProcs
    jfsInit
    jfsDatInit
  TCFileSections = array[TCFileSection, Rope]
  TCProcSection = enum
    jpsLocals
    jpsInit
    jpsStmts
  TCProcSections = array[TCProcSection, Rope]

proc newGlobals(): PGlobals =
  new(result)

proc newModule(graph: ModuleGraph; module: PSym): BModule =
  new(result)
  result.module = module
  result.graph = graph
  result.config = graph.config
  if graph.backend == nil:
    let g = newGlobals()
    result.g = g
    graph.backend = g
  else:
    result.g = PGlobals(graph.backend)

proc newProc(m: BModule; prc: PSym): BProc =
  new(result)
  result.m = m
  result.prc = prc

template config*(p: BProc): ConfigRef =
  p.m.config

# {{{ writing lines and indenting them

proc s*(p: BProc; s: TCProcSection): var Rope {.inline.} =
  # section in the current block
  result = p.blocks[^1].sections[s]

proc procSec*(p: BProc, s: TCProcSection): var Rope {.inline.} =
  # top level proc sections
  result = p.blocks[0].sections[s]

import macros

proc pjsSym(m: BModule; name: string): Rope

proc pjsFormatValue(result: var string; value: Rope): void =
  for str in leaves(value):
    result.add(str)

proc pjsFormatValue(result: var string; value: string): void =
  result.add(value)

proc pjsFormatValue(result: var string; value: BiggestInt): void =
  result.addInt(value)

proc pjsFormatValue(result: var string; value: Int128): void =
  result.addInt128(value)

# TODO: please document
macro ropejs(m: BModule, frmt: static[FormatStr], args: untyped): Rope =
  args.expectKind nnkBracket
  # echo "ropecg ", newLit(frmt).repr, ", ", args.repr
  var i = 0
  var length = len(frmt)
  result = nnkStmtListExpr.newTree()

  result.add quote do:
    assert `m` != nil

  let resVar = genSym(nskVar, "res")
  # during `koch boot` the median of all generates strings from this
  # macro is around 40 bytes in length.
  result.add newVarStmt(resVar, newCall(bindSym"newStringOfCap", newLit(80)))
  let formatValue = bindSym"pjsFormatValue"

  var num = 0
  var strLit = ""

  template flushStrLit() =
    if strLit != "":
      result.add newCall(ident "add", resVar, newLit(strLit))
      strLit.setLen 0

  while i < length:
    if frmt[i] == '$':
      inc(i)                  # skip '$'
      case frmt[i]
      of '$':
        strLit.add '$'
        inc(i)
      of '#':
        flushStrLit()
        inc(i)
        result.add newCall(formatValue, resVar, args[num])
        inc(num)
      of '0'..'9':
        var j = 0
        while true:
          j = (j * 10) + ord(frmt[i]) - ord('0')
          inc(i)
          if i >= length or not (frmt[i] in {'0'..'9'}): break
        num = j
        if j > len(args):
          error("ropes: invalid format string " & newLit(frmt).repr & " args.len: " & $args.len)

        flushStrLit()
        result.add newCall(formatValue, resVar, args[j-1])
      of 'n':
        flushStrLit()
        result.add quote do:
          if optLineDir notin `m`.config.options:
            add(`resVar`, "\L")
        inc(i)
      of 'N':
        strLit.add "\L"
        inc(i)
      else:
        error("ropes: invalid format string $" & frmt[i])
    elif frmt[i] == '#' and frmt[i+1] in IdentStartChars:
      inc(i)
      var j = i
      while frmt[j] in IdentChars: inc(j)
      var ident = newLit(substr(frmt, i, j-1))
      i = j
      flushStrLit()
      result.add newCall(formatValue, resVar, newCall(ident"pjsSym", m, ident))
    elif frmt[i] == '#' and frmt[i+1] == '$':
      inc(i, 2)
      var j = 0
      while frmt[i] in Digits:
        j = (j * 10) + ord(frmt[i]) - ord('0')
        inc(i)
      let ident = args[j-1]
      flushStrLit()
      result.add newCall(formatValue, resVar, newCall(ident"pjsSym", m, ident))
    var start = i
    while i < length:
      if frmt[i] != '$' and frmt[i] != '#': inc(i)
      else: break
    if i - 1 >= start:
      add(strLit, substr(frmt, start, i - 1))

  flushStrLit()
  result.add newCall(ident"rope", resVar)

proc indentLine(p: BProc, r: Rope): Rope =
  result = r
  for i in 0 ..< p.blocks.len:
    prepend(result, "\t".rope)

template appjs(m: BModule, c: var Rope, frmt: FormatStr, args: untyped) =
  add(c, ropejs(m, frmt, args))

template appjs(m: BModule, sec: TCFileSection, frmt: FormatStr, args: untyped) =
  add(m.s[sec], ropejs(m, frmt, args))

template appjs(p: BProc, sec: TCProcSection, frmt: FormatStr, args: untyped) =
  add(p.s(sec), ropejs(p.m, frmt, args))

template line(p: BProc, sec: TCProcSection, r: Rope) =
  add(p.s(sec), indentLine(p, r))

template line(p: BProc, sec: TCProcSection, r: string) =
  add(p.s(sec), indentLine(p, r.rope))

template lineF(p: BProc, sec: TCProcSection, frmt: FormatStr, args: untyped) =
  add(p.s(sec), indentLine(p, frmt % args))

template lineJs(p: BProc, sec: TCProcSection, frmt: FormatStr, args: untyped) =
  add(p.s(sec), indentLine(p, ropejs(p.m, frmt, args)))

template linefmt(p: BProc, sec: TCProcSection, frmt: FormatStr, args: untyped) =
  add(p.s(sec), indentLine(p, ropejs(p.m, frmt, args)))

# }}}
# {{{ name mangling

proc mangleName(m: BModule, s: PSym): Rope =
  proc validJsName(name: string): bool =
    result = true
    const reservedWords = ["abstract", "await", "boolean", "break", "byte",
      "case", "catch", "char", "class", "const", "continue", "debugger",
      "default", "delete", "do", "double", "else", "enum", "export", "extends",
      "false", "final", "finally", "float", "for", "function", "goto", "if",
      "implements", "import", "in", "instanceof", "int", "interface", "let",
      "long", "native", "new", "null", "package", "private", "protected",
      "public", "return", "short", "static", "super", "switch", "synchronized",
      "this", "throw", "throws", "transient", "true", "try", "typeof", "var",
      "void", "volatile", "while", "with", "yield"]
    case name
    of reservedWords:
      return false
    else:
      discard
    if name[0] in {'0'..'9'}: return false
    for chr in name:
      if chr notin {'A'..'Z','a'..'z','_','$','0'..'9'}:
        return false
  result = s.loc.r
  if result == nil:
    if s.kind == skField and s.name.s.validJsName:
      result = rope(s.name.s)
    elif s.kind == skTemp:
      result = rope(mangle(s.name.s))
    else:
      var x = newStringOfCap(s.name.s.len)
      var i = 0
      while i < s.name.s.len:
        let c = s.name.s[i]
        case c
        of 'A'..'Z':
          if i > 0 and s.name.s[i-1] in {'a'..'z'}:
            x.add '_'
          x.add(chr(c.ord - 'A'.ord + 'a'.ord))
        of 'a'..'z', '_', '0'..'9':
          x.add c
        else:
          x.add("HEX" & toHex(ord(c), 2))
        inc i
      result = rope(x)
    # From ES5 on reserved words can be used as object field names
    if s.kind != skField:
      add(result, "_")
      add(result, rope(s.id))
    s.loc.r = result

# }}}
# {{{ JS escape string literal

proc escapeJSString(s: string): string =
  result = newStringOfCap(s.len + s.len shr 2)
  result.add("\"")
  for c in items(s):
    case c
    of '\l': result.add("\\n")
    of '\r': result.add("\\r")
    of '\t': result.add("\\t")
    of '\b': result.add("\\b")
    of '\a': result.add("\\a")
    of '\e': result.add("\\e")
    of '\v': result.add("\\v")
    of '\\': result.add("\\\\")
    of '\"': result.add("\\\"")
    else: add(result, c)
  result.add("\"")

proc makeJSString(s: string, escapeNonAscii = true): Rope =
  if escapeNonAscii:
    result = strutils.escape(s).rope
  else:
    result = escapeJSString(s).rope

# }}}
# {{{ Blocks

proc startBlockInternal(p: BProc): int {.discardable.} =
  #inc(p.labels)
  result = len(p.blocks)
  setLen(p.blocks, result + 1)
  #p.blocks[result].id = p.labels
  #p.blocks[result].nestedTryStmts = p.nestedTryStmts.len.int16
  #p.blocks[result].nestedExceptStmts = p.inExceptBlockLen.int16

template startBlock(p: BProc, start: FormatStr = "{$n",
                args: varargs[Rope]): int =
  lineJs(p, cpsStmts, start, args)
  startBlockInternal(p)

proc blockBody(b: var TBlock): Rope =
  result = b.sections[jpsLocals]
  result.add(b.sections[jpsInit])
  result.add(b.sections[jpsStmts])

proc endBlock(p: BProc, blockEnd: Rope) =
  let topBlock = p.blocks.len-1
  # the block is merged into the parent block
  add(p.blocks[topBlock-1].sections[jpsStmts], p.blocks[topBlock].blockBody)
  setLen(p.blocks, topBlock)
  # this is done after the block is popped so $n is
  # properly indented when pretty printing is enabled
  line(p, jpsStmts, blockEnd)

# }}}
# {{{ types

# Types that are irrelevant to this backend, and thus can be safely ignored.
const IrrelevantTypesForBackend = {tyGenericBody, tyGenericInst, tyGenericInvocation,
                          tyDistinct, tyRange, tyStatic, tyAlias, tySink,
                          tyInferred, tyOwned}

proc getTypeDescAux(m: BModule, origTyp: PType, check: var IntSet): Rope

proc isImportedType(t: PType): bool {.inline.} =
  result = t.sym != nil and sfImportc in t.sym.flags

proc isImportedCppType(t: PType): bool =
  let x = t.skipTypes(IrrelevantTypesForBackend)
  result = (t.sym != nil and sfInfixCall in t.sym.flags) or
           (x.sym != nil and sfInfixCall in x.sym.flags)

proc typeName(typ: PType): Rope =
  let typ = typ.skipTypes(IrrelevantTypesForBackend)
  result =
    if typ.sym != nil and typ.kind in {tyObject, tyEnum}:
      rope($typ.kind & '_' & typ.sym.name.s.mangle)
    else:
      rope($typ.kind)

proc getTypeName(m: BModule; typ: PType; sig: SigHash): Rope =
  var t = typ
  while true:
    if t.sym != nil and {sfImportc, sfExportc} * t.sym.flags != {}:
      return t.sym.loc.r

    if t.kind in IrrelevantTypesForBackend:
      t = t.lastSon
    else:
      break
  let typ = if typ.kind in {tyAlias, tySink, tyOwned}: typ.lastSon else: typ
  if typ.loc.r == nil:
    typ.loc.r = typ.typeName & $sig
  else:
    when defined(debugSigHashes):
      # check consistency:
      assert($typ.loc.r == $(typ.typeName & $sig))
  result = typ.loc.r
  if result == nil: internalError(m.config, "getTypeName: " & $typ.kind)

proc mapSetType(conf: ConfigRef; typ: PType): TPjsTypeKind =
  case int(getSize(conf, typ))
  of 1: result = etyInt8
  of 2: result = etyInt16
  of 4: result = etyInt32
  else: result = etyArray

proc mapType(conf: ConfigRef; typ: PType): TPjsTypeKind =
  ## Maps a Nim type to a PJS type
  let t = skipTypes(typ, abstractInst)
  case t.kind
  of tyNone, tyTyped: result = etyVoid
  of tyBool: result = etyBool
  of tyChar: result = etyUint8
  of tySet: result = mapSetType(conf, typ)
  of tyOpenArray, tyArray, tyVarargs, tyUncheckedArray: result = etyArray
  of tyObject, tyTuple: result = etyStruct
  of tyUserTypeClasses:
    doAssert typ.isResolvedUserTypeClass
    result = mapType(conf, typ.lastSon)
  of tyGenericBody, tyGenericInst, tyGenericParam, tyDistinct, tyOrdinal,
     tyTypeDesc, tyAlias, tySink, tyInferred, tyOwned:
    result = mapType(conf, lastSon(typ))
  of tyEnum:
    if firstOrd(conf, typ) < 0:
      result = etyInt32
    else:
      case int(getSize(conf, typ)):
      of 1: result = etyUint8
      of 2: result = etyUint16
      of 4: result = etyInt32
      else: result = etyInt32
  of tyRange:
    result = mapType(conf, typ.sons[0])
  of tyRef: result = etyRef
  of tySequence: result = etyNimSeq
  of tyProc: result = etyProc
  of tyString: result = etyNimStr
  of tyCString: result = etyString
  of tyInt8: result = etyInt8
  of tyInt16: result = etyInt16
  of tyInt, tyInt32: result = etyInt32
  of tyFloat32: result = etyFloat32
  of tyFloat, tyFloat64: result = etyFloat64
  of tyUInt8: result = etyUint8
  of tyUInt16: result = etyUint16
  of tyUInt, tyUInt32: result = etyUint32
  of tyStatic:
    if typ.n != nil:
      result = mapType(conf, lastSon(typ))
    else:
      doAssert(false, "mapType")
  else:
    internalError(conf, "cannot map to PJS type: " & $typ.kind)

proc cacheGetType(tab: TypeCache; sig: SigHash): Rope =
  # returns nil if we need to declare this type.
  # since types are now unique via the ``getUniqueType`` mechanism,
  # this slow linear search is not necessary anymore:
  result = tab.getOrDefault(sig)

proc typeNameOrLiteral(m: BModule; t: PType, literal: string): Rope =
  if t.sym != nil and sfImportc in t.sym.flags and t.sym.magic == mNone:
    result = t.sym.loc.r
  else:
    result = rope(literal)

proc pushType(m: BModule; typ: PType): void =
  for i in 0 .. high(m.typeStack):
    # pointer equality is good enough here:
    if m.typeStack[i] == typ: return
  add(m.typeStack, typ)

proc getSimpleTypeDesc(m: BModule; typ: PType): Rope =
  const NumericalTypeToStr: array[tyInt..tyUInt64, string] = [
    "i32", "i8", "i16", "i32", "i64", "f64", "f32", "f64", "f128",
    "u32", "u8", "u16", "u32", "u64"]
  case typ.kind
  of tyString:
    # discard cgsym(m, "NimStringDesc")
    result = typeNameOrLiteral(m, typ, "NimStringDesc")
  of tyCString:
    result = typeNameOrLiteral(m, typ, "string")
  of tyBool:
    result = typeNameOrLiteral(m, typ, "bool")
  of tyChar:
    result = typeNameOrLiteral(m, typ, "u8")
  of tyInt..tyUInt64:
    result = typeNameOrLiteral(m, typ, NumericalTypeToStr[typ.kind])
  of tyDistinct, tyRange, tyOrdinal:
    result = getSimpleTypeDesc(m, typ.sons[0])
  of tyStatic:
    if typ.n != nil:
      result = getSimpleTypeDesc(m, lastSon(typ))
    else:
      internalError(m.config, "tyStatic for getSimpleTypeDesc")
  of tyGenericInst, tyAlias, tySink, tyOwned:
    result = getSimpleTypeDesc(m, lastSon(typ))
  else:
    result = nil
  if result != nil and typ.isImportedType():
    let sig = hashType(typ)
    if cacheGetType(m.typeCache, sig) == nil:
      m.typeCache[sig] = result

proc structOrUnion(t: PType): Rope =
  let cachedUnion {.global.} = rope("union")
  let cachedStruct {.global.} = rope("struct")
  let t = t.skipTypes({tyAlias, tySink})
  if tfUnion in t.flags: cachedUnion
  else: cachedStruct

proc addForwardStructFormat(m: BModule, structOrUnion: Rope, typename: Rope) =
  # e.g. struct Foo;
  m.s[jfsForwardTypes].addf("$1 $2;$n", [structOrUnion, typename])

proc wrapRef(typename: Rope): Rope =
  let cachedRef {.global.} = rope("ref[")
  let cachedRefEnd {.global.} = rope("]")
  cachedRef & typename & cachedRefEnd

proc getTypePre(m: BModule, typ: PType; sig: SigHash): Rope =
  if typ == nil:
    result = rope("void")
  else:
    result = getSimpleTypeDesc(m, typ)
    if result == nil:
      result = cacheGetType(m.typeCache, sig)

proc getTypeForward(m: BModule, typ: PType; sig: SigHash): Rope =
  result = cacheGetType(m.forwTypeCache, sig)
  if result != nil: return
  result = getTypePre(m, typ, sig)
  if result != nil: return
  let concrete = typ.skipTypes(abstractInst + {tyOpt})
  case concrete.kind
  of tySequence, tyTuple, tyObject:
    result = getTypeName(m, typ, sig)
    m.forwTypeCache[sig] = result
    if not isImportedType(concrete):
      addForwardStructFormat(m, structOrUnion(typ), result)
    else:
      pushType(m, concrete)
    doAssert m.forwTypeCache[sig] == result
  else: internalError(m.config, "getTypeForward(" & $typ.kind & ')')

proc getTypeDescWeak(m: BModule; t: PType; check: var IntSet): Rope =
  ## like getTypeDescAux but creates only a *weak* dependency.
  ## In other words we know we only need a pointer to it so we only generate
  ## a struct forward declaration:
  let etB = t.skipTypes(abstractInst)
  case etB.kind
  of tyObject, tyTuple:
    result = getTypeForward(m, t, hashType(t))
    pushType(m, t)
  of tySequence:
    let sig = hashType(t)
    result = wrapRef(getTypeForward(m, t, sig))
    pushType(m, t)
  else:
    result = getTypeDescAux(m, t, check)

proc getTypeDescAux(m: BModule, origTyp: PType, check: var IntSet): Rope =
  # returns only the type's name
  var t = origTyp.skipTypes(IrrelevantTypesForBackend)
  if containsOrIncl(check, t.id):
    if not (isImportedCppType(origTyp) or isImportedCppType(t)):
      internalError(m.config, "cannot generate C type for: " & typeToString(origTyp))
    # XXX: this BUG is hard to fix -> we need to introduce helper structs,
    # but determining when this needs to be done is hard. We should split
    # C type generation into an analysis and a code generation phase somehow.
  let sig = hashType(origTyp)
  result = getTypePre(m, t, sig)
  if result != nil:
    excl(check, t.id)
    return
  case t.kind
  of tyRef:
    var et = origTyp.skipTypes(abstractInst).lastSon
    var etB = et.skipTypes(abstractInst)
    case etB.kind
    of tyObject, tyTuple:
      if isImportedCppType(etB) and et.kind == tyGenericInst:
        result = wrapRef(getTypeDescAux(m, et, check))
      else:
        # No restriction! We have a forward declaration for structs
        let name = getTypeForward(m, et, hashType(et))
        result = wrapRef(name)
        m.typeCache[sig] = result
    of tySequence:
      # No restriction! We have a forward declaration for structs
      let name = getTypeForward(m, et, hashType(et))
      result = wrapRef(name)
      m.typeCache[sig] = result
      pushType(m, et)
    else:
      # else we have a strong dependency :-(
      result = wrapRef(getTypeDescAux(m, et, check))
      m.typeCache[sig] = result
  of tyOpenArray, tyVarargs:
    result = wrapRef(getTypeDescWeak(m, t.sons[0], check))
    m.typeCache[sig] = result
  of tyEnum:
    result = cacheGetType(m.typeCache, sig)
    if result == nil:
      result = getTypeName(m, origTyp, sig)
      if not (isImportedCppType(t) or (sfImportc in t.sym.flags and t.sym.magic == mNone)):
        m.typeCache[sig] = result
        var size: int
        if firstOrd(m.config, t) < 0:
          addf(m.s[jfsTypes], "type $1 = i32;$n", [result])
          size = 4
        else:
          size = int(getSize(m.config, t))
          case size
          of 1: addf(m.s[jfsTypes], "type $1 = u8;$n", [result])
          of 2: addf(m.s[jfsTypes], "type $1 = u16;$n", [result])
          of 4: addf(m.s[jfsTypes], "type $1 = i32;$n", [result])
          else: internalError(m.config, t.sym.info, "getTypeDescAux: enum")
  of tyProc:
    result = getTypeName(m, origTyp, sig)
    m.typeCache[sig] = result
    var rettype, desc: Rope
    #TODO
    #genProcParams(m, t, rettype, desc, check, true, true)
    if not isImportedType(t):
      addf(m.s[jfsTypes], "type $2 = fn ($1, $3);$n", [rettype, result, desc])
  else:
    internalError(m.config, "getTypeDescAux(" & $t.kind & ')')
    result = nil

proc getTypeDesc(m: BModule, typ: PType): Rope =
  var check = initIntSet()
  result = getTypeDescAux(m, typ, check)

# }}}
# {{{ gen

proc genStmt(p: BProc, n: PNode): void
proc gen(p: BProc, n: PNode, r: var TCompRes): void

proc isIndirect(v: PSym): bool {.inline.} =
  {sfAddrTaken, sfGlobal} * v.flags != {} and {sfImportc, sfExportc} * v.flags == {} and v.kind notin {skProc, skFunc, skConverter, skMethod, skIterator, skConst, skTemp, skLet}

proc genLineDir(p: BProc, n: PNode): void =
  # TODO: Support linedir?
  discard

proc genVarInit(p: BProc, v: PSym, n: PNode) =
  var a: TCompRes
  var s: Rope
  var varCode: string
  var varName = mangleName(p.m, v)
  var t = getTypeDesc(p.m, v.typ)
  appjs(p, jpsLocals, "let $1: $2;$n", [varName, t])

proc genVarStmt(p: BProc, n: PNode) =
  for i in 0 ..< len(n):
    var a = n.sons[i]
    if a.kind != nkCommentStmt:
      if a.kind == nkVarTuple:
        let unpacked = lowerTupleUnpacking(p.m.graph, a, p.prc)
        genStmt(p, unpacked)
      else:
        assert(a.kind == nkIdentDefs)
        assert(a.sons[0].kind == nkSym)
        var v = a.sons[0].sym
        if lfNoDecl notin v.loc.flags and sfImportc notin v.flags:
          genLineDir(p, a)
          if sfCompileTime notin v.flags:
            genVarInit(p, v, a.sons[2])
          else:
            # lazy emit, done when it's actually used.
            if v.ast == nil: v.ast = a[2]

proc gen(p: BProc, n: PNode, r: var TCompRes): void =
  r.typ = etyVoid
  r.kind = resNone
  case n.kind
  of nkCharLit..nkUInt64Lit:
    if n.typ.kind == tyBool:
      r.res = if n.intVal == 0: rope"false" else: rope"true"
    else:
      r.res = rope(n.intVal)
    r.kind = resExpr
  of nkStmtList, nkStmtListExpr:
    # this shows the distinction is nice for backends and should be kept
    # in the frontend
    let isExpr = not isEmptyType(n.typ)
    for i in 0 ..< len(n) - isExpr.ord:
      genStmt(p, n.sons[i])
    if isExpr:
      gen(p, lastSon(n), r)
  of nkVarSection, nkLetSection:
    genVarStmt(p, n)
  of nkConstSection:
    discard
  of nkTypeSection, nkCommentStmt, nkIteratorDef, nkIncludeStmt,
     nkImportStmt, nkImportExceptStmt, nkExportStmt, nkExportExceptStmt,
     nkFromStmt, nkTemplateDef, nkMacroDef, nkStaticStmt:
    discard
  else:
    internalError(p.config, n.info, "gen: unknown node type: " & $n.kind)

proc genStmt(p: BProc, n: PNode): void =
  var r: TCompRes
  gen(p, n, r)
  if r.res != nil:
    lineF(p, jpsStmts, "$#;$n", [r.res])

proc genModule(p: BProc, n: PNode): void =
  var transformedN = transformStmt(p.m.graph, p.m.module, n)
  genStmt(p, transformedN)

proc genProc(m: BModule; prc: PSym): void =
  discard

proc pjsSym(m: BModule; name: string): Rope =
  let sym = magicsys.getCompilerProc(m.graph, name)
  if sym != nil:
    case sym.kind
    of skProc, skFunc, skMethod, skConverter, skIterator: genProc(m, sym)
    of skType: discard getTypeDesc(m, sym.typ)
    else: internalError(m.config, "pjsSym: " & name & ": " & $sym.kind)
  else:
    rawMessage(m.config, errGenerated, "system module needs: " & name)
  result = sym.loc.r

# }}}
# {{{

proc wholeCode(m: BModule): Rope =
  let globals = PGlobals(m.graph.backend)
  result = globals.code

proc myOpen(graph: ModuleGraph; module: PSym): PPassContext =
  result = newModule(graph, module)

proc myProcess(b: PPassContext, n: PNode): PNode =
  result = n
  if b == nil: return
  let m = BModule(b)
  if passes.skipCodegen(m.config, n):
    return
  let p = newProc(m, nil)
  genModule(p, n)

proc myClose(graph: ModuleGraph; b: PPassContext; n: PNode): PNode =
  result = myProcess(b, n)
  let m = BModule(b)
  if sfMainModule in m.module.flags:
    let code = wholeCode(m)
    let outFile = m.config.prepareToWriteOutput()
    discard writeRopeIfNotEqual(code, outFile)

const PjsGenPass* = makePass(myOpen, myProcess, myClose)

# }}}
# vim: set foldmethod=marker:
